(in-package :pathgen)

(defmacro for-all-rows ((grid row) &body body)
  `(iter (for ,row :from 0 :below (height ,grid))
	 ,@body))
(defmacro for-all-columns ((grid column) &body body)
  `(iter (for ,column :from 0 :below (width ,grid))
	 ,@body))
(defmacro for-all-nodes ((grid node) &body body)
  (let ((row (gensym "row"))
	(column (gensym "column")))
    `(for-all-rows (,grid ,row)
       (for-all-columns (,grid ,column)
	 (let ((,node (grid-node ,grid ,row ,column)))
	   ,@body)))))

(defun invert-direction (direction)
  (case direction
    (:up :down)
    (:left :right)
    (:right :left)
    (:down :up)
    (otherwise :none)))

(defun make-conditions-form (conditions)
  `(and ,@(iter (for (condition-type node-name direction) in conditions)
		(when (not (eq :is-free-node condition-type))
		  (error "unhandled condition type ~a" condition-type))
		(collect `(and
			   (can-extend-in-direction-p ,node-name ,direction)
			   (node-available-p (neighbouring-node ,node-name ,direction)))))))
(defun make-path-modification-form (form)
  (destructuring-bind (node-tag node-name path-direction direction) form
    (declare (ignorable node-tag))
    (case path-direction
      (:next `(setf (direction ,node-name) ,direction))
      (:prev `(setf (rev-direction ,node-name) ,direction))
      (otherwise (error "unknown direction [~a] in path modification form ~a" direction form)))))
(defun make-path-modification-forms (forms)
  (iter (for form in forms)
	(collect (make-path-modification-form form))))
(defun make-node-insertion-form (form)
  (destructuring-bind (node-tag node-name direction-tag direction prev-tag prev-direction next-tag next-direction) form
    (declare (ignorable node-tag direction-tag prev-tag next-tag))
    (let ((new-node-name (gensym "new-node")))
      `(let ((,new-node-name (neighbouring-node ,node-name ,direction)))
	 (setf (direction ,new-node-name) ,next-direction)
	 (setf (rev-direction ,new-node-name) ,prev-direction)))))
(defun make-node-insertion-forms (forms)
  (iter (for node-insertion-form in forms)
	(collect (make-node-insertion-form node-insertion-form))))
(defun make-node-deletion-form (form)
  (destructuring-bind (node-tag node-name) form
    (declare (ignorable node-tag))
    `((setf (direction ,node-name) :none)
      (setf (rev-direction ,node-name) :none))))
(defun make-node-deletion-forms (forms)
  (iter (for node-deletion-form in forms)
	(appending (make-node-deletion-form node-deletion-form))))
(defun make-path-mods-form (specs)
  (iter (for data on specs by 'cddr)
	(destructuring-bind (key forms &rest rest) data
	  (declare (ignorable rest))
	  (case key
	    (:node-deletions (appending (make-node-deletion-forms forms)))
	    (:node-insertions (appending (make-node-insertion-forms forms)))
	    (:path-modifications (appending (make-path-modification-forms forms)))
	    ((:name :category :conditions))
	    (otherwise (error "unknown path modification operation ~a" key))))))

(defmacro make-extension (&body body)
  `(make-instance 'extension
		  :name ,(getf body :name)
		  :category ,(getf body :category)
		  :first-node first-node
		  :second-node second-node
		  :third-node third-node
		  :conditions #'(lambda ()
				  (and first-node second-node third-node
				       ,(make-conditions-form (getf body :conditions))))
		  :path-modifications #'(lambda () ,@(make-path-mods-form body))))

(defmacro make-linear-extension (&body body)
  (let ((extension-direction (getf body :extension-direction))
	(inv-extension-direction (invert-direction (getf body :extension-direction)))
	(original-direction (getf body :original-direction))
	(inv-original-direction (invert-direction (getf body :original-direction))))
    (destructuring-bind (node-1 node-2) (getf body :nodes)
      `(make-extension :name ,(getf body :name)
		       :category ,(getf body :category)
		       :conditions ((:is-free-node ,node-1 ,extension-direction)
				    (:is-free-node ,node-2 ,extension-direction))
		       :node-insertions ((:node ,node-1 :direction ,extension-direction 
						:prev ,inv-extension-direction :next ,original-direction)
					 (:node ,node-2 :direction ,extension-direction 
						:prev ,inv-original-direction :next ,inv-extension-direction))
		       :path-modifications ((:node ,node-1 :next ,extension-direction)
					    (:node ,node-2 :prev ,extension-direction))))))
(defmacro make-horizontal-right-extension (&body body)
  `(make-linear-extension :category :horizontal-right :original-direction :right ,@body))
(defmacro make-horizontal-left-extension (&body body)
  `(make-linear-extension :category :horizontal-left :original-direction :left ,@body))
(defmacro make-vertical-down-extension (&body body)
  `(make-linear-extension :category :vertical-down :original-direction :down ,@body))
(defmacro make-vertical-up-extension (&body body)
  `(make-linear-extension :category :vertical-up :original-direction :up ,@body))

(defmacro make-corner-extension (&body body)
  `(make-extension :category ,(getf body :name)
		   :name ,(getf body :name)
		   :conditions ((:is-free-node first-node ,(second (getf body :directions))))
		   :node-deletions ((:node second-node))
		   :node-insertions ((:node first-node :direction ,(second (getf body :directions))
					    :prev ,(invert-direction (second (getf body :directions)))
					    :next ,(first (getf body :directions))))
		   :path-modifications ((:node first-node :next ,(second (getf body :directions)))
					(:node third-node :prev ,(invert-direction (first (getf body :directions)))))))

