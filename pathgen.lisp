;;;; pathgen.lisp

(in-package #:pathgen)

;;; "pathgen" goes here. Hacks and glory await!

(defclass path-node ()
  ((row :initarg :row :initform 0 :accessor row)
   (column :initarg :column :initform 0 :accessor column)
   (direction :initarg :direction :initform :nn :accessor direction)
   (rev-direction :initarg :direction :initform :nn :accessor rev-direction)))


(defclass grid ()
  ((width :initarg :width :initform 10 :accessor width)
   (height :initarg :height :initform 10 :accessor height)
   (grid-nodes :initform nil :accessor grid-nodes)))

(defmacro for-all-rows ((grid row) &body body)
  `(iter (for ,row :from 0 :below (height ,grid))
	 ,@body))
(defmacro for-all-columns ((grid column) &body body)
  `(iter (for ,column :from 0 :below (width ,grid))
	 ,@body))

(defmethod initialize-instance :after ((grid grid) &key)
  (setf (grid-nodes grid) (make-array (list (height grid) (width grid))))
  (for-all-rows (grid row)
    (for-all-columns (grid column)
      (setf (grid-node grid row column) (make-instance 'path-node :row row :column column)))))

(defmethod grid-node ((grid grid) row column)
  (aref (grid-nodes grid) row column))
(defsetf grid-node (grid row column) (new-value)
  `(setf (aref (grid-nodes ,grid) ,row ,column) ,new-value))

(defmethod possible-directions ((grid grid) row column)
  (cond ((= 0 row) (cond ((= 0 column) '(:rt :dn))
			 ((= (1- (width grid)) column) '(:lt :dn))
			 (t  '(:rt :dn :lt))))
	((= (1- (height grid)) row) (cond ((= 0 column) '(:rt :up))
					  ((= (1- (width grid)) column) '(:lt :up))
					  (t '(:rt :up :lt))))
	((= 0 column) '(:up :dn :rt))
	((= (1- (width grid)) column) '(:up :dn :lt))
	(t '(:up :dn :lt :rt))))

(defmethod node-direction ((grid grid) row column)
  (direction (grid-node grid row column)))
(defsetf node-direction (grid row column) (new-value)
  `(setf (direction (grid-node ,grid ,row ,column)) ,new-value))
(defmethod rev-node-direction ((grid grid) row column)
  (rev-direction (grid-node grid row column)))
(defsetf rev-node-direction (grid row column) (new-value)
  `(setf (rev-direction (grid-node ,grid ,row ,column)) ,new-value))

(defun invert-direction (direction)
  (case direction
    (:up :dn)
    (:lt :rt)
    (:rt :lt)
    (:dn :up)
    (otherwise :nn)))
(defun init-rev-grid-directions (grid)
  (for-all-rows (grid row)
    (for-all-columns (grid column)
      (let ((direction (node-direction grid row column)))
       (when (not (eq :nn direction))
	 (destructuring-bind (erow ecolumn) (extend-in-direction row column direction)
	   (setf (rev-node-direction grid erow ecolumn) (invert-direction direction))))))))
(defun initialize-initial-path (grid)
  (for-all-rows (grid row)
    (for-all-columns (grid column)
      (setf (node-direction grid row column) :nn)))
  (for-all-rows (grid row)
    (setf (node-direction grid row 0) :dn))
  (for-all-columns (grid column)
    (setf (node-direction grid (1- (height grid)) column) :rt))
  (setf (node-direction grid (1- (height grid)) (1- (width grid))) :nn)
  (init-rev-grid-directions grid)
  grid)


(defun direction-rep (direction)
  (case direction
    (:up "^")
    (:dn "v")
    (:lt "<")
    (:rt ">")
    (otherwise ".")))
(defmethod print-object ((grid grid) stream)
  (print-unreadable-object (grid stream)
    (for-all-rows (grid row)
      (format stream "~%")
      (for-all-columns (grid column)
	(format stream "[~a|~a] " 
		(direction-rep (node-direction grid row column))
		(direction-rep (rev-node-direction grid row column)))))))

(defun extend-in-direction (row column direction)
  (case direction
    (:lt (list row (1- column)))
    (:rt (list row (1+ column)))
    (:up (list (1- row) column))
    (:dn (list (1+ row) column))))
(defun find-random-node-on-path (grid)
  (let ((row (random (height grid)))
	(column (random (width grid))))
    (iter (until (not (eq :nn (node-direction grid row column))))
	  (setf row (random (height grid)))
	  (setf column (random (width grid))))
    (list row column)))
(defun find-possible-extensions (grid row column)
  (let ((directions (possible-directions grid row column)))
    (iter (for direction in directions)
	  (destructuring-bind (erow ecolumn) (extend-in-direction row column direction)
	    ))))
(defun try-to-extend-path (grid)
  (destructuring-bind (row column) (find-random-node-on-path grid)
    (let ((possible-extensions (find-possible-extensions grid row column)))
      )))
